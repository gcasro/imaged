{"version":3,"file":"Crop.js","sources":["../src/helpers.ts","../src/Crop.ts"],"sourcesContent":["/**\n * Find target element in DOM starting from either a CSS selector or an element instance.\n * @param selector Target image specified as string (CSS selector) or HTMLImageElement.\n */\nexport function getImage(selector: string | HTMLImageElement): HTMLImageElement {\n    let image: HTMLImageElement | null = null;\n\n    if (typeof selector === \"string\") {\n        image = document.querySelector(selector);\n    } else {\n        image = selector;\n    }\n\n    if (!(image instanceof HTMLImageElement)) {\n        throw new Error(\"Crop target must be an image element or a CSS selector pointing to one.\");\n    }\n\n    return image;\n}\n\nexport function px(x: number) {\n    return x.toString() + \"px\";\n}\n","import CropStyles from \"./Crop.css\";\n\nimport { getImage, px } from \"./helpers\";\n\nconst instanceKey = \"__imagedCropInstance\";\n\n/**\n * Crop options.\n */\nexport type CropOptions = {\n    /**\n     * Draw a rounded viewport instead of rectangular.\n     */\n    roundFrame: boolean;\n\n    /**\n     * Enforce an aspect ratio (width / height) on the viewport.\n     */\n    aspectRatio: number;\n\n    /**\n     * Use this color as background for cropping transparent images.\n     * By default black (#ffffff) is used.\n     */\n    backgroundColor: string;\n\n    /**\n     * Event listener called every time the selection is updated (and at start).\n     * Takes no arguments; use the `to*()` methods to obtain the actual image.\n     * The `this` object will be the very instance of Crop which this is given to.\n     */\n    onCrop: (this: Crop) => void;\n\n    /**\n     * Minimum or maximum output image size in pixels.\n     */\n    minOutputWidth: number;\n    minOutputHeight: number;\n    maxOutputWidth: number;\n    maxOutputHeight: number;\n\n    /**\n     * Container element where the Crop panel should be appended (at the end).\n     * Normally, the parent of the target image is used but you can control that.\n     *\n     * Container MUST be the exact same size as the image and must have `position`\n     * style set to one of `relative | absolute | fixed`.\n     */\n    container: string | HTMLElement;\n\n    /**\n     * Append CSS styles over the internal ones (inside Shadow DOM).\n     */\n    additionalStyles: string;\n};\n\nenum EAspectRule {\n    SCALE_WIDTH,\n    SCALE_HEIGHT,\n    SCALE_BOTH,\n}\n\ntype CropSelection = { x1: number; y1: number; x2: number; y2: number };\ntype KnobCofficients = {\n    rule: EAspectRule;\n\n    // Multipliers for applying translation deltas on the selection.\n    dx1: number;\n    dy1: number;\n    dx2: number;\n    dy2: number;\n\n    // Multipliers for applying aspect ratio corrections on the selection.\n    ax1: number;\n    ay1: number;\n    ax2: number;\n    ay2: number;\n};\n\n/**\n * The main Crop interface.\n *\n * The main usage principle is to place the image you need cropped into the DOM,\n * wherever you like, and then instantiate the Crop on that image. The Crop\n * will overlay all its resources over the existing image.\n */\nexport default class Crop {\n    // Original image.\n    protected image: HTMLImageElement;\n\n    // Toolset.\n    protected panel: HTMLDivElement;\n    protected frame: HTMLDivElement;\n    protected light: SVGRectElement;\n    protected shade: SVGRectElement;\n\n    // UI change observers.\n    protected listeners: { [event: string]: (event: any) => void } = {};\n\n    // Selection.\n    protected canvas: HTMLCanvasElement;\n    protected selection: CropSelection = { x1: 0, y1: 0, x2: 0, y2: 0 };\n    protected oldSelection: CropSelection = { x1: 0, y1: 0, x2: 0, y2: 0 };\n    protected minApparentWidth: number = 0;\n    protected minApparentHeight: number = 0;\n    protected maxApparentWidth: number = 0;\n    protected maxApparentHeight: number = 0;\n\n    // Knob coefficient matrix (determines how each knob modifies the selection when dragged).\n    protected coefficients: { [key: string]: KnobCofficients } = {\n        n: { dx1: 0, dy1: 1, dx2: 0, dy2: 0, ax1: 0.5, ay1: 1, ax2: 0.5, ay2: 0, rule: EAspectRule.SCALE_HEIGHT },\n        e: { dx1: 0, dy1: 0, dx2: 1, dy2: 0, ax1: 0, ay1: 0.5, ax2: 1, ay2: 0.5, rule: EAspectRule.SCALE_WIDTH },\n        s: { dx1: 0, dy1: 0, dx2: 0, dy2: 1, ax1: 0.5, ay1: 0, ax2: 0.5, ay2: 1, rule: EAspectRule.SCALE_HEIGHT },\n        w: { dx1: 1, dy1: 0, dx2: 0, dy2: 0, ax1: 1, ay1: 0.5, ax2: 0, ay2: 0.5, rule: EAspectRule.SCALE_WIDTH },\n\n        ne: { dx1: 0, dy1: 1, dx2: 1, dy2: 0, ax1: 0, ay1: 1, ax2: 1, ay2: 0, rule: EAspectRule.SCALE_BOTH },\n        se: { dx1: 0, dy1: 0, dx2: 1, dy2: 1, ax1: 0, ay1: 0, ax2: 1, ay2: 1, rule: EAspectRule.SCALE_BOTH },\n        sw: { dx1: 1, dy1: 0, dx2: 0, dy2: 1, ax1: 1, ay1: 0, ax2: 0, ay2: 1, rule: EAspectRule.SCALE_BOTH },\n        nw: { dx1: 1, dy1: 1, dx2: 0, dy2: 0, ax1: 1, ay1: 1, ax2: 0, ay2: 0, rule: EAspectRule.SCALE_BOTH },\n\n        frame: { dx1: 1, dy1: 1, dx2: 1, dy2: 1, ax1: 0, ay1: 0, ax2: 0, ay2: 0, rule: EAspectRule.SCALE_BOTH },\n    };\n\n    // Dragging handlers.\n    protected activeKnob: string | undefined = undefined;\n    protected xOffset: number = 0;\n    protected yOffset: number = 0;\n\n    protected initializeDragEvents() {\n        this.listeners.dragStart = (event: MouseEvent | TouchEvent) => {\n            if (window.TouchEvent && event instanceof TouchEvent) {\n                this.xOffset = event.touches[0].clientX;\n                this.yOffset = event.touches[0].clientY;\n            } else {\n                this.xOffset = (<MouseEvent>event).clientX;\n                this.yOffset = (<MouseEvent>event).clientY;\n            }\n            const node = event.target as HTMLElement;\n            const knob = this.coefficients[node.id];\n            if (knob) {\n                this.oldSelection = this.selection;\n                this.activeKnob = node.id;\n            }\n            node.classList.add(\"active\");\n        };\n\n        this.listeners.dragEnd = (_event: MouseEvent | TouchEvent) => {\n            if (this.activeKnob) {\n                this.panel.shadowRoot?.getElementById(this.activeKnob)?.classList.remove(\"active\");\n                this.activeKnob = undefined;\n            }\n        };\n\n        this.listeners.drag = (event: MouseEvent | TouchEvent) => {\n            if (this.activeKnob) {\n                let xDelta: number;\n                let yDelta: number;\n                if (window.TouchEvent && event instanceof TouchEvent) {\n                    xDelta = event.touches[0].clientX - this.xOffset;\n                    yDelta = event.touches[0].clientY - this.yOffset;\n                } else {\n                    xDelta = (<MouseEvent>event).clientX - this.xOffset;\n                    yDelta = (<MouseEvent>event).clientY - this.yOffset;\n                }\n                this.updateSelection(xDelta, yDelta);\n            }\n        };\n\n        document.addEventListener(\"touchend\", this.listeners.dragEnd, false);\n        document.addEventListener(\"touchmove\", this.listeners.drag, false);\n        document.addEventListener(\"mouseup\", this.listeners.dragEnd, false);\n        document.addEventListener(\"mousemove\", this.listeners.drag, false);\n        const initializeKnob = (knob?: HTMLDivElement | null) => {\n            knob?.addEventListener(\"touchstart\", this.listeners.dragStart, false);\n            knob?.addEventListener(\"mousedown\", this.listeners.dragStart, false);\n        };\n        Object.keys(this.coefficients).forEach((key) => initializeKnob(this.frame.querySelector<HTMLDivElement>(\"#\" + key)));\n        initializeKnob(this.frame);\n    }\n\n    protected initializeSelection() {\n        // Initial placement.\n        const bounds = this.image.getBoundingClientRect();\n        const sourceRatio = bounds.width / bounds.height;\n        const targetRatio = this.options?.aspectRatio || sourceRatio;\n        let width: number = bounds.width;\n        let height: number = bounds.height;\n        if (targetRatio > sourceRatio) {\n            height = width / targetRatio;\n        } else {\n            width = height * targetRatio;\n        }\n        this.selection = {\n            x1: bounds.width / 2 - width / 2,\n            y1: bounds.height / 2 - height / 2,\n            x2: bounds.width / 2 + width / 2,\n            y2: bounds.height / 2 + height / 2,\n        };\n        this.oldSelection = this.selection;\n\n        // Establish bounds.\n        this.minApparentWidth = 32;\n        if (this.options?.minOutputWidth) {\n            this.minApparentWidth = Math.min(\n                bounds.width,\n                Math.max(this.minApparentWidth, this.options.minOutputWidth * (bounds.width / this.image.naturalWidth))\n            );\n        }\n        this.minApparentHeight = 32;\n        if (this.options?.minOutputHeight) {\n            this.minApparentHeight = Math.min(\n                bounds.height,\n                Math.max(this.minApparentHeight, this.options.minOutputHeight * (bounds.height / this.image.naturalHeight))\n            );\n        }\n        this.maxApparentWidth = bounds.width;\n        if (this.options?.maxOutputWidth) {\n            this.maxApparentWidth = Math.min(this.maxApparentWidth, this.options.maxOutputWidth * (bounds.width / this.image.naturalWidth));\n        }\n        this.maxApparentHeight = bounds.height;\n        if (this.options?.maxOutputHeight) {\n            this.maxApparentHeight = Math.min(this.maxApparentHeight, this.options.maxOutputHeight * (bounds.height / this.image.naturalHeight));\n        }\n\n        // Calibrate selection at start.\n        this.updateSelection(0, 0);\n    }\n\n    protected enforceAspectRatio(selection: CropSelection, coefficients: KnobCofficients, rule: EAspectRule) {\n        const ratio = this.options?.aspectRatio;\n        if (ratio) {\n            const width = selection.x2 - selection.x1;\n            const height = selection.y2 - selection.y1;\n\n            let newWidth: number = width;\n            let newHeight: number = height;\n\n            switch (rule) {\n                case EAspectRule.SCALE_WIDTH:\n                    newHeight = width / ratio;\n                    break;\n                case EAspectRule.SCALE_HEIGHT:\n                    newWidth = height * ratio;\n                    break;\n                case EAspectRule.SCALE_BOTH:\n                    if (width / ratio > height) {\n                        newWidth = height * ratio;\n                    } else {\n                        newHeight = width / ratio;\n                    }\n                    break;\n            }\n\n            selection.x1 -= coefficients.ax1 * (newWidth - width);\n            selection.y1 -= coefficients.ay1 * (newHeight - height);\n            selection.x2 += coefficients.ax2 * (newWidth - width);\n            selection.y2 += coefficients.ay2 * (newHeight - height);\n        }\n    }\n\n    protected updateSelection(xDelta: number, yDelta: number) {\n        const bounds = this.image.getBoundingClientRect();\n        const coefficients = this.coefficients[this.activeKnob || \"frame\"];\n\n        // Apply translation deltas.\n        const newSelection = {\n            x1: this.oldSelection.x1 + coefficients.dx1 * xDelta,\n            y1: this.oldSelection.y1 + coefficients.dy1 * yDelta,\n            x2: this.oldSelection.x2 + coefficients.dx2 * xDelta,\n            y2: this.oldSelection.y2 + coefficients.dy2 * yDelta,\n        };\n\n        // Adjust selection according to aspect ratio rules.\n        this.enforceAspectRatio(newSelection, coefficients, coefficients.rule);\n\n        // Enforce edge constraints (clip/move selection).\n        if (newSelection.x1 < 0) {\n            newSelection.x2 -= newSelection.x1 * coefficients.dx2;\n            newSelection.x2 += newSelection.x1 * coefficients.ax2 * 2;\n            newSelection.x1 = 0;\n        }\n        if (newSelection.y1 < 0) {\n            newSelection.y2 -= newSelection.y1 * coefficients.dy2;\n            newSelection.y2 += newSelection.y1 * coefficients.ay2 * 2;\n            newSelection.y1 = 0;\n        }\n        if (newSelection.x2 > bounds.width) {\n            const delta = newSelection.x2 - bounds.width;\n            newSelection.x1 -= delta * coefficients.dx1;\n            newSelection.x1 += delta * coefficients.ax1 * 2;\n            newSelection.x2 = bounds.width;\n        }\n        if (newSelection.y2 > bounds.height) {\n            const delta = newSelection.y2 - bounds.height;\n            newSelection.y1 -= delta * coefficients.dy1;\n            newSelection.y1 += delta * coefficients.ay1 * 2;\n            newSelection.y2 = bounds.height;\n        }\n\n        // Enforce size constraints.\n        const width = newSelection.x2 - newSelection.x1;\n        const height = newSelection.y2 - newSelection.y1;\n        if (width < this.minApparentWidth) {\n            const delta = this.minApparentWidth - width;\n            newSelection.x1 -= delta * coefficients.ax1;\n            newSelection.x2 += delta * coefficients.ax2;\n        }\n        if (width > this.maxApparentWidth) {\n            newSelection.x1 = this.selection.x1;\n            newSelection.x2 = this.selection.x1 + this.maxApparentWidth;\n        }\n        if (height < this.minApparentHeight) {\n            const delta = this.minApparentHeight - height;\n            newSelection.y1 -= delta * coefficients.ay1;\n            newSelection.y2 += delta * coefficients.ay2;\n        }\n        if (height > this.maxApparentHeight) {\n            newSelection.y1 = this.selection.y1;\n            newSelection.y2 = this.selection.y1 + this.maxApparentHeight;\n        }\n\n        // After clipping, ensure that entire selection is contained to aspect ratio.\n        this.enforceAspectRatio(newSelection, coefficients, EAspectRule.SCALE_BOTH);\n\n        // Apply selection.\n        this.selection = newSelection;\n        this.refreshSelection();\n    }\n\n    protected refreshSelection() {\n        this.light.setAttribute(\"x\", px(this.selection.x1));\n        this.light.setAttribute(\"y\", px(this.selection.y1));\n        this.light.setAttribute(\"width\", px(this.selection.x2 - this.selection.x1));\n        this.light.setAttribute(\"height\", px(this.selection.y2 - this.selection.y1));\n\n        this.frame.style.left = px(this.selection.x1);\n        this.frame.style.top = px(this.selection.y1);\n        this.frame.style.width = px(this.selection.x2 - this.selection.x1);\n        this.frame.style.height = px(this.selection.y2 - this.selection.y1);\n\n        this.options?.onCrop?.call(this);\n    }\n\n    /**\n     * Instantiate the Crop over an existing image.\n     *\n     * @param target The target image to crop (CSS selector string or HTMLImageElement).\n     */\n    constructor(target: string | HTMLImageElement, readonly options?: Partial<CropOptions>) {\n        this.image = getImage(target);\n\n        // Make sure only one crop is instantiated per image.\n        if (this.image.dataset[instanceKey]) {\n            throw new Error(\"ImagedCrop: Target image already has a Crop instance attached!\");\n        }\n        this.image.dataset[instanceKey] = \"true\";\n\n        // Build tools (inlined styles ensure priorty over CSS stylesheets).\n        this.panel = document.createElement(\"div\");\n        this.panel.style.position = \"absolute\";\n        this.panel.style.border = \"none\";\n        this.panel.style.background = \"none\";\n        this.panel.style.left = px(0);\n        this.panel.style.top = px(0);\n        this.panel.style.right = px(0);\n        this.panel.style.bottom = px(0);\n        const panelShadowRoot = this.panel.attachShadow({ mode: \"open\" });\n        panelShadowRoot.innerHTML = `\n            <style>\n                ${CropStyles}\n                ${options?.additionalStyles || \"\"}\n            </style>\n            <svg id=\"overlay\" xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" height=\"100%\">\n                <mask id=\"mask\">\n                    <rect id=\"shade\" fill=\"#fff\" />\n                    <rect id=\"light\" fill=\"#000\" ${this.options?.roundFrame ? 'rx=\"50%\" ry=\"50%\"' : \"\"} />\n                </mask>\n                <rect x=\"0%\" y=\"0%\" width=\"100%\" height=\"100%\" fill=\"currentFill\" mask=\"url(#mask)\" />\n            </svg>\n        `;\n        this.frame = document.createElement(\"div\");\n        this.frame.setAttribute(\"id\", \"frame\");\n        this.frame.style.position = \"absolute\";\n        this.frame.style.borderRadius = this.options?.roundFrame ? \"50%\" : \"0\";\n        this.frame.innerHTML = `\n            <div id=\"n\" class=\"knob\" style=\"position: absolute;\"></div>\n            <div id=\"ne\" class=\"knob\" style=\"position: absolute;\"></div>\n            <div id=\"e\" class=\"knob\" style=\"position: absolute;\"></div>\n            <div id=\"se\" class=\"knob\" style=\"position: absolute;\"></div>\n            <div id=\"s\" class=\"knob\" style=\"position: absolute;\"></div>\n            <div id=\"sw\" class=\"knob\" style=\"position: absolute;\"></div>\n            <div id=\"w\" class=\"knob\" style=\"position: absolute;\"></div>\n            <div id=\"nw\" class=\"knob\" style=\"position: absolute;\"></div>\n            <div id=\"legend\"></div>\n        `;\n        panelShadowRoot.appendChild(this.frame);\n        this.light = panelShadowRoot.querySelector<SVGRectElement>(\"#light\")!;\n        this.shade = panelShadowRoot.querySelector<SVGRectElement>(\"#shade\")!;\n        this.shade.setAttribute(\"x\", px(0));\n        this.shade.setAttribute(\"y\", px(0));\n        this.shade.setAttribute(\"width\", \"100%\");\n        this.shade.setAttribute(\"height\", \"100%\");\n        this.canvas = document.createElement(\"canvas\");\n\n        // Initialize.\n        this.initializeDragEvents();\n        this.initializeSelection();\n\n        // Inject into DOM.\n        let container: string | HTMLElement | null = this.options?.container || this.image.parentElement;\n        if (typeof container === \"string\") {\n            container = document.querySelector<HTMLElement>(container);\n        }\n        container?.appendChild(this.panel);\n        if (!container) {\n            throw new Error(\"ImagedCrop: Invalid container specified!\");\n        }\n    }\n\n    /**\n     * Returns the selection coordinates in image space.\n     * @returns { x, y, width, height } The cropped image coordinates.\n     */\n    toCoordinates(): { x: number; y: number; width: number; height: number } {\n        const bounds = this.image.getBoundingClientRect();\n        const x = Math.round((this.selection.x1 / bounds.width) * this.image.naturalWidth);\n        const x2 = Math.round((this.selection.x2 / bounds.width) * this.image.naturalWidth);\n        const y = Math.round((this.selection.y1 / bounds.height) * this.image.naturalHeight);\n        const y2 = Math.round((this.selection.y2 / bounds.height) * this.image.naturalHeight);\n        const width = x2 - x;\n        const height = y2 - y;\n        return { x, y, width, height };\n    }\n\n    /**\n     * This method does two things:\n     * 1. Updates the internal canvas object with the cropped image;\n     * 2. Returns the internal canvas object.\n     * To show this canvas, call this method and insert the returned canvas into the DOM.\n     * To update the canvas in real-time, invoke this method from the `onCrop` event handler.\n     * @returns HTMLCanvasElement A Canvas object.\n     */\n    toCanvas(): HTMLCanvasElement {\n        const selection = this.toCoordinates();\n        this.canvas.width = selection.width;\n        this.canvas.height = selection.height;\n        const context = this.canvas.getContext(\"2d\");\n        if (context) {\n            context.fillStyle = this.options?.backgroundColor || \"#ffffff\";\n            context.fillRect(0, 0, selection.width, selection.height);\n            context.drawImage(this.image, selection.x, selection.y, selection.width, selection.height, 0, 0, selection.width, selection.height);\n        }\n        return this.canvas;\n    }\n\n    /**\n     * Executes the crop and returns the cropped image as a data URL ready to be assigned\n     * into the `src` attribute of an `<img>` tag.\n     * @param mime An image mime type such as \"image/jpeg\" or \"image/png\" (default: \"image/png\").\n     * @param quality A number between 0 and 1 designating encoding quality for lossy formats (e.g. \"image/jpeg\").\n     * @returns string The image data as a data URI.\n     */\n    toDataUrl(mime: string = \"image/png\", quality?: number): string {\n        const canvas = this.toCanvas();\n        return canvas.toDataURL(mime, quality);\n    }\n\n    /**\n     * Asynchronously executes the crop and returns the cropped image as file data.\n     * @param mime An image mime type such as \"image/jpeg\" or \"image/png\" (default: \"image/png\").\n     * @param quality A number between 0 and 1 designating encoding quality for lossy formats (e.g. \"image/jpeg\").\n     * @returns Promise<Blob> The image file data.\n     */\n    async toBlob(mime: string = \"image/png\", quality?: number): Promise<Blob> {\n        const canvas = this.toCanvas();\n        return new Promise((resolve, reject) => {\n            canvas.toBlob(\n                (blob) => {\n                    if (!blob) {\n                        reject(\"Failed to crop image!\");\n                    } else {\n                        resolve(blob);\n                    }\n                },\n                mime,\n                quality\n            );\n        });\n    }\n\n    /**\n     * Destroys the Crop instance and deletes all resources.\n     */\n    destroy() {\n        document.removeEventListener(\"touchend\", this.listeners.dragEnd, false);\n        document.removeEventListener(\"touchmove\", this.listeners.drag, false);\n        document.removeEventListener(\"mouseup\", this.listeners.dragEnd, false);\n        document.removeEventListener(\"mousemove\", this.listeners.drag, false);\n\n        // All other events will be canceled when the panel is removed from DOM.\n\n        this.panel?.remove();\n        delete this.image.dataset[instanceKey];\n    }\n}\n"],"names":["px","x","toString","instanceKey","EAspectRule","initializeDragEvents","this","listeners","dragStart","event","window","TouchEvent","xOffset","touches","clientX","yOffset","clientY","node","target","coefficients","id","oldSelection","selection","activeKnob","classList","add","dragEnd","_event","_b","_a","panel","shadowRoot","getElementById","remove","undefined","drag","xDelta","yDelta","updateSelection","document","addEventListener","initializeKnob","knob","Object","keys","forEach","key","frame","querySelector","initializeSelection","bounds","image","getBoundingClientRect","sourceRatio","width","height","targetRatio","options","aspectRatio","x1","y1","x2","y2","minApparentWidth","minOutputWidth","Math","min","max","naturalWidth","minApparentHeight","_c","minOutputHeight","naturalHeight","maxApparentWidth","_d","maxOutputWidth","maxApparentHeight","_e","maxOutputHeight","enforceAspectRatio","rule","ratio","newWidth","newHeight","SCALE_WIDTH","SCALE_HEIGHT","SCALE_BOTH","ax1","ay1","ax2","ay2","newSelection","dx1","dy1","dx2","dy2","delta","refreshSelection","light","setAttribute","style","left","top","onCrop","call","constructor","n","e","s","w","ne","se","sw","nw","selector","HTMLImageElement","Error","getImage","dataset","createElement","position","border","background","right","bottom","panelShadowRoot","attachShadow","mode","innerHTML","additionalStyles","roundFrame","borderRadius","appendChild","shade","canvas","container","parentElement","toCoordinates","round","y","toCanvas","context","getContext","fillStyle","backgroundColor","fillRect","drawImage","toDataUrl","mime","quality","toDataURL","async","Promise","resolve","reject","toBlob","blob","destroy","removeEventListener"],"mappings":"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"}